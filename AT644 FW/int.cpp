/****************************************************************************
**	INCLUDE
****************************************************************************/

//type definition using the bit width and signedness
#include <stdint.h>
//define the ISR routune, ISR vector, and the sei() cli() function
#include <avr/interrupt.h>
//name all the register and bit
#include <avr/io.h>

//General purpose macros
#include "at_utils.h"
//ATMEGA PORT macros definitions
#include "at_mega_port.h"

#include "global.h"

/****************************************************************************
**GLOBAL VARS
****************************************************************************/

/****************************************************************************
** INTERRUPT SERVICE ROUTINE
*****************************************************************************
**	In the AT4809 ISR flags have to be cleared manually
****************************************************************************/

/****************************************************************************
**	Periodic Interrupt
*****************************************************************************
**	Periodic interrupt generated by the RTC from it's independent clock source
**		system tick
**	Fastest tick for general fast operations
**		control system
**	Issue the execution of the control system for the motors
**		slow tick
**	Issue a slow tick meant for non time critical communication and housekeeping tasks
****************************************************************************/

ISR( TIMER0_COMPA_vect )
{	
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------

	//Prescaler for slow tick
	static uint8_t pre_slow = 0;
	static uint8_t pre_ctrl_sys = 0;

	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------

	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------	
	
		//----------------------------------------------------------------
		//	FAST CONTROL SYSTEM TICK
		//----------------------------------------------------------------	

	//Detect if a control system execution is still pending
	if (g_isr_flags.ctrl_fast_updt == true)
	{
		//Report pending
		g_isr_flags.err_pending = true;
	}
	//Fast 
	g_isr_flags.ctrl_fast_updt = true;
	
		//----------------------------------------------------------------
		//	SLOW CONTROL SYSTEM TICK
		//----------------------------------------------------------------
	
	//If: control system is executed every fast tick
	if (Prescaler::TOP_SLOW_CTRL_SYS == 0)
	{
		//Detect if a control system execution is still pending
		if (g_isr_flags.ctrl_slow_updt == true)
		{
			//Report pending
			g_isr_flags.err_pending = true;
		}
		
		//Issue Control System Execution
		g_isr_flags.ctrl_slow_updt = true;
	}
	//If: 
	else
	{		
		//If: Control System Tick Tick
		if (pre_ctrl_sys == 0)
		{
			//Detect if a control system execution is still pending
			if (g_isr_flags.ctrl_slow_updt == true)
			{
				//Report pending
				g_isr_flags.err_pending = true;
			}
			
			//Issue Control System Execution
			g_isr_flags.ctrl_slow_updt = true;
		}
		pre_ctrl_sys = AT_TOP_INC( pre_ctrl_sys, Prescaler::TOP_SLOW_CTRL_SYS );
	}
	
		//----------------------------------------------------------------
		//	SLOW TICK
		//----------------------------------------------------------------
	
	//If: Slow Tick
	if (pre_slow == 0)
	{
		//Issue a slow tick
		g_isr_flags.slow_tick = true;
	}
	pre_slow = AT_TOP_INC( pre_slow, Prescaler::TOP_SLOW_TICK );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
}

/****************************************************************************
**	USART3 RX Interrupt
*****************************************************************************
**	
****************************************************************************/

ISR( USART0_RX_vect )
{
	//----------------------------------------------------------------
	//	VARS
	//----------------------------------------------------------------
	
	//Temp var
	uint8_t rx_data_tmp;
	
	//----------------------------------------------------------------
	//	INIT
	//----------------------------------------------------------------
	
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//Fetch the data and clear the interrupt flag
	rx_data_tmp = UDR0;
	
	if (AT_BUF_NUMELEM(rpi_rx_buf)>=(RPI_RX_BUF_SIZE-1))
	{
		//An overflow occurred on the RX buffer. Ask main to handle it.
		g_isr_flags.rx_buf_ovf = true;
	}
	else
	{
		//Push byte into RX buffer for processing
		AT_BUF_PUSH_SAFER( rpi_rx_buf, rx_data_tmp );	
	}
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------	
	
}	//End ISR: USART3_RXC_vect

/****************************************************************************
**  ISR
**  PCINT1_vect
****************************************************************************/
//! @brief 
//! @details
//! Detect pin change on Encoder B
//!	PC6, PCINT22	: ENC-A A Channel
//!	PC7, PCINT23	: ENC-A B Channel
//!	PB0, PCINT8		: ENC-B A Channel
//!	PB1, PCINT9		: ENC-B B Channel
/***************************************************************************/

ISR( PCINT1_vect )
{	
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//Construct encoder word. Encoder A on Bit 0 and Bit 1. Encoder B on Bit 2 and Bit 3.
	uint8_t enc_data = ((PINC & 0xc0) >> 6) | ((PINB & 0x03) << 2);
	
	//quad channel encoder decoder routine
	quad_encoder_decoder( enc_data );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
} //End ISR: PCINT1_vect

/****************************************************************************
**  ISR
**  PCINT2_vect
****************************************************************************/
//! @brief
//! @details
//! Detect pin change on Encoder A
//!	PC6, PCINT22	: ENC-A A Channel
//!	PC7, PCINT23	: ENC-A B Channel
//!	PB0, PCINT8		: ENC-B A Channel
//!	PB1, PCINT9		: ENC-B B Channel
/***************************************************************************/

ISR( PCINT2_vect )
{
	//----------------------------------------------------------------
	//	BODY
	//----------------------------------------------------------------
	
	//Construct encoder word. Encoder A on Bit 0 and Bit 1. Encoder B on Bit 2 and Bit 3.
	uint8_t enc_data = ((PINC & 0xc0) >> 6) | ((PINB & 0x03) << 2);
	
	//quad channel encoder decoder routine
	quad_encoder_decoder( enc_data );
	
	//----------------------------------------------------------------
	//	RETURN
	//----------------------------------------------------------------
	
} //End ISR: PCINT2_vect



